# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
#   sqlc-gen-better-python v0.4.5
from __future__ import annotations

__all__: collections.abc.Sequence[str] = (
    "QueryResults",
    "create_message",
    "get_messages",
)

import operator
import typing

if typing.TYPE_CHECKING:
    import aiosqlite
    import collections.abc
    import sqlite3

    QueryResultsArgsType: typing.TypeAlias = int | float | str | memoryview | None

from coding_agent.persistence import models


CREATE_MESSAGE: typing.Final[str] = """-- name: CreateMessage :one
INSERT INTO chat_sessions (
  session_id, message_role, content
) VALUES (
  ?, ?, ?
)
RETURNING id, session_id, message_role, content, created_at
"""

GET_MESSAGES: typing.Final[str] = """-- name: GetMessages :many
SELECT (message_role, content) FROM chat_sessions
WHERE session_id = ?
"""


T = typing.TypeVar("T")


class QueryResults(typing.Generic[T]):
    __slots__ = ("_args", "_conn", "_cursor", "_decode_hook", "_iterator", "_sql")

    def __init__(
        self,
        conn: aiosqlite.Connection,
        sql: str,
        decode_hook: collections.abc.Callable[[sqlite3.Row], T],
        *args: QueryResultsArgsType,
    ) -> None:
        self._conn = conn
        self._sql = sql
        self._decode_hook = decode_hook
        self._args = args
        self._cursor: aiosqlite.Cursor | None = None
        self._iterator: collections.abc.AsyncIterator[sqlite3.Row] | None = None

    def __aiter__(self) -> QueryResults[T]:
        return self

    def __await__(
        self,
    ) -> collections.abc.Generator[None, None, collections.abc.Sequence[T]]:
        async def _wrapper() -> collections.abc.Sequence[T]:
            result = await (await self._conn.execute(self._sql, self._args)).fetchall()
            return [self._decode_hook(row) for row in result]

        return _wrapper().__await__()

    async def __anext__(self) -> T:
        if self._cursor is None or self._iterator is None:
            self._cursor: aiosqlite.Cursor | None = await self._conn.execute(
                self._sql, self._args
            )
            self._iterator = self._cursor.__aiter__()
        try:
            record = await self._iterator.__anext__()
        except StopAsyncIteration:
            self._cursor = None
            self._iterator = None
            raise
        return self._decode_hook(record)


async def create_message(
    conn: aiosqlite.Connection,
    *,
    session_id: str,
    message_role: str,
    content: str | None,
) -> models.ChatSession | None:
    row = await (
        await conn.execute(CREATE_MESSAGE, (session_id, message_role, content))
    ).fetchone()
    if row is None:
        return None
    return models.ChatSession(
        id=row[0],
        session_id=row[1],
        message_role=row[2],
        content=row[3],
        created_at=row[4],
    )


def get_messages(
    conn: aiosqlite.Connection, *, session_id: str
) -> QueryResults[typing.Any]:
    return QueryResults[typing.Any](
        conn, GET_MESSAGES, operator.itemgetter(0), session_id
    )
